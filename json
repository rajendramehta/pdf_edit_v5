from flask import Flask, request, render_template, send_file
import os
import fitz  # PyMuPDF
import pandas as pd
import xml.etree.ElementTree as ET
import pyreadstat
import uuid
import shutil
import zipfile
from werkzeug.utils import secure_filename

app = Flask(__name__, template_folder="templates")
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB max

UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)


# ---------------- File Processing Functions ----------------

def replace_text_in_pdf(input_pdf_path, old_text, new_text):
    pdf_document = fitz.open(input_pdf_path)
    font_name = "Times-Roman"

    for page in pdf_document:
        text_instances = page.search_for(old_text)
        if text_instances:
            original_text_info = page.get_text("dict")['blocks']

            for rect in text_instances:
                page.add_redact_annot(rect)
            page.apply_redactions()

            for rect in text_instances:
                original_fontsize = 12
                for block in original_text_info:
                    for line in block.get("lines", []):
                        for span in line.get("spans", []):
                            if old_text in span["text"]:
                                original_fontsize = span["size"]
                                break
                font_params = {'fontsize': original_fontsize, 'fontname': font_name}
                insert_point = fitz.Point(rect.x0, rect.y1 - 2.5)
                page.insert_text(insert_point, new_text, **font_params)

    output_path = input_pdf_path.replace('.pdf', '_modified.pdf')
    pdf_document.save(output_path)
    pdf_document.close()
    return output_path


def replace_text_in_csv(input_csv_path, old_text, new_text):
    df = pd.read_csv(input_csv_path, dtype=str)
    df = df.applymap(lambda x: x.replace(old_text, new_text) if isinstance(x, str) else x)
    output_path = input_csv_path.replace('.csv', '_modified.csv')
    df.to_csv(output_path, index=False)
    return output_path


def replace_text_in_xml(input_xml_path, old_text, new_text):
    tree = ET.parse(input_xml_path)
    root = tree.getroot()

    def replace_in_element(elem):
        if elem.text and old_text in elem.text:
            elem.text = elem.text.replace(old_text, new_text)
        if elem.tail and old_text in elem.tail:
            elem.tail = elem.tail.replace(old_text, new_text)
        for k, v in elem.attrib.items():
            if old_text in v:
                elem.attrib[k] = v.replace(old_text, new_text)
        for child in elem:
            replace_in_element(child)

    replace_in_element(root)
    output_path = input_xml_path.replace('.xml', '_modified.xml')
    tree.write(output_path, encoding="utf-8", xml_declaration=True)
    return output_path


def replace_text_in_xpt(input_xpt_path, old_text, new_text):
    df, meta = pyreadstat.read_xport(input_xpt_path)
    df = df.applymap(lambda x: x.replace(old_text, new_text) if isinstance(x, str) else x)
    output_path = input_xpt_path.replace('.xpt', '_modified.xpt')
    pyreadstat.write_xport(df, output_path, file_format_version=8, table_name=meta.table_name)
    return output_path


def process_single_file(file_path, old_text, new_text):
    ext = os.path.splitext(file_path)[1].lower()
    if ext == '.pdf':
        return replace_text_in_pdf(file_path, old_text, new_text)
    elif ext == '.csv':
        return replace_text_in_csv(file_path, old_text, new_text)
    elif ext == '.xml':
        return replace_text_in_xml(file_path, old_text, new_text)
    elif ext == '.xpt':
        return replace_text_in_xpt(file_path, old_text, new_text)
    else:
        return None


def extract_zip_and_process(zip_path, old_text, new_text):
    extract_folder = os.path.join(UPLOAD_FOLDER, f"extracted_{uuid.uuid4()}")
    os.makedirs(extract_folder)
    processed_files = []
    supported_extensions = ['.pdf', '.csv', '.xml', '.xpt']

    try:
        with zipfile.ZipFile(zip_path, 'r') as zip_ref:
            zip_ref.extractall(extract_folder)

        for root, dirs, files in os.walk(extract_folder):
            for file in files:
                file_path = os.path.join(root, file)
                ext = os.path.splitext(file)[1].lower()
                if ext in supported_extensions:
                    processed_file = process_single_file(file_path, old_text, new_text)
                    if processed_file:
                        processed_files.append(processed_file)

        if processed_files:
            output_zip = zip_path.replace('.zip', '_modified.zip')
            with zipfile.ZipFile(output_zip, 'w') as zip_ref:
                for processed_file in processed_files:
                    zip_ref.write(processed_file, os.path.basename(processed_file))
            return output_zip
        else:
            return None
    finally:
        shutil.rmtree(extract_folder, ignore_errors=True)


# ---------------- Routes ----------------

@app.route('/')
def index():
    return render_template('index.html')


@app.route('/upload', methods=['POST'])
def upload_file():
    try:
        old_text = request.form.get('old_text', '').strip()
        new_text = request.form.get('new_text', '').strip()
        if not old_text:
            return render_template("index.html", error="Text to find is required")

        uploaded_files = request.files.getlist('pdf_file')
        if not uploaded_files or all(file.filename == '' for file in uploaded_files):
            return render_template("index.html", error="No files selected")

        processed_files = []
        supported_extensions = ['.pdf', '.csv', '.xml', '.xpt', '.zip']

        for file in uploaded_files:
            if file.filename == '':
                continue
            filename = secure_filename(file.filename)
            ext = os.path.splitext(filename)[1].lower()
            if ext not in supported_extensions:
                return render_template("index.html", error=f"Unsupported file type: {ext}")

            unique_filename = f"{uuid.uuid4()}_{filename}"
            file_path = os.path.join(UPLOAD_FOLDER, unique_filename)
            file.save(file_path)

            if ext == '.zip':
                output_path = extract_zip_and_process(file_path, old_text, new_text)
            else:
                output_path = process_single_file(file_path, old_text, new_text)

            if output_path:
                processed_files.append({'path': output_path, 'name': f"modified_{filename}"})
            else:
                return render_template("index.html", error=f"Failed to process {filename}")

        if not processed_files:
            return render_template("index.html", error="No files processed successfully")

        if len(processed_files) == 1:
            return send_file(
                processed_files[0]['path'],
                as_attachment=True,
                download_name=processed_files[0]['name'],
                mimetype='application/octet-stream'
            )
        else:
            zip_filename = f"modified_files_{uuid.uuid4()}.zip"
            zip_path = os.path.join(UPLOAD_FOLDER, zip_filename)
            with zipfile.ZipFile(zip_path, 'w') as zip_ref:
                for processed_file in processed_files:
                    zip_ref.write(processed_file['path'], processed_file['name'])
            return send_file(zip_path, as_attachment=True, download_name=zip_filename, mimetype='application/zip')

    except Exception as e:
        return render_template("index.html", error=f"Server error: {str(e)}")


if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

























<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document Text Replacer</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      background: #f7f9fc;
      margin: 0;
      padding: 20px;
    }

    .navbar {
      background: #667eea;
      color: white;
      padding: 15px;
      font-size: 1.2rem;
      font-weight: bold;
      text-align: center;
      border-radius: 8px;
      margin-bottom: 20px;
    }

    .container {
      background: white;
      border-radius: 12px;
      padding: 30px;
      max-width: 600px;
      margin: auto;
      box-shadow: 0 8px 20px rgba(0,0,0,0.1);
    }

    h1 {
      text-align: center;
      color: #333;
      margin-bottom: 10px;
    }

    p.subtitle {
      text-align: center;
      color: #666;
      margin-bottom: 20px;
    }

    .form-group {
      margin-bottom: 20px;
    }

    label {
      display: block;
      font-weight: bold;
      margin-bottom: 8px;
      color: #444;
    }

    input[type="text"], input[type="file"] {
      width: 100%;
      padding: 12px;
      border: 2px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      transition: border-color 0.3s;
    }

    input[type="text"]:focus, input[type="file"]:focus {
      border-color: #667eea;
      outline: none;
    }

    .file-types {
      font-size: 0.85rem;
      color: #777;
      margin-top: 5px;
    }

    .btn {
      display: inline-block;
      width: 100%;
      padding: 14px;
      font-size: 1rem;
      font-weight: bold;
      color: white;
      background: linear-gradient(135deg, #667eea, #764ba2);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    .btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 4px 12px rgba(102, 126, 234, 0.3);
    }

    .error-message {
      background: rgba(220, 53, 69, 0.1);
      color: #dc3545;
      padding: 12px;
      border: 1px solid rgba(220, 53, 69, 0.3);
      border-radius: 8px;
      margin-bottom: 20px;
      text-align: center;
      font-weight: bold;
    }
  </style>
</head>
<body>
  <div class="navbar">
    Document Text Replacer
  </div>

  <div class="container">
    <h1>Replace Text in Documents</h1>
    <p class="subtitle">Upload your files, enter text, and download modified versions instantly</p>

    <!-- ✅ Show error if passed by Flask -->
    {% if error %}
      <div class="error-message">{{ error }}</div>
    {% endif %}

    <!-- ✅ Real form for direct download -->
    <form action="/upload" method="post" enctype="multipart/form-data">
      <div class="form-group">
        <label for="old_text">Text to Find</label>
        <input type="text" id="old_text" name="old_text" placeholder="Enter text to replace..." required>
      </div>

      <div class="form-group">
        <label for="new_text">Replace With</label>
        <input type="text" id="new_text" name="new_text" placeholder="Enter replacement text...">
      </div>

      <div class="form-group">
        <label for="pdf-file-input">Upload Documents</label>
        <input type="file" name="pdf_file" id="pdf-file-input" accept=".pdf,.csv,.xml,.xpt,.zip" multiple required>
        <div class="file-types">Supported: PDF, CSV, XML, XPT, ZIP (Max 50MB)</div>
      </div>

      <button type="submit" class="btn">Process & Download</button>
    </form>
  </div>
</body>
</html>
