# Simple single-file Flask application - no templates needed
# This eliminates template-related issues

from flask import Flask, request, send_file, jsonify
import os
import fitz  # PyMuPDF
import pandas as pd
import xml.etree.ElementTree as ET
import pyreadstat
import uuid
import shutil
import zipfile
from werkzeug.utils import secure_filename
import threading
import traceback

app = Flask(__name__)
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB max file size

# Create uploads directory
UPLOAD_FOLDER = 'uploads'
if not os.path.exists(UPLOAD_FOLDER):
    os.makedirs(UPLOAD_FOLDER)

# Store processed files temporarily
processed_files_cache = {}

# ---------------- HTML Template (embedded) ----------------
HTML_TEMPLATE = '''<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Text Replacer</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh; padding: 20px; 
        }
        .container {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            padding: 30px; max-width: 600px; margin: 0 auto;
        }
        h1 { color: #333; text-align: center; margin-bottom: 30px; }
        .form-group { margin-bottom: 20px; }
        label { display: block; margin-bottom: 8px; color: #555; font-weight: 600; }
        input[type="text"] {
            width: 100%; padding: 12px; border: 2px solid #e1e5e9;
            border-radius: 8px; font-size: 1rem;
        }
        input[type="text"]:focus { outline: none; border-color: #667eea; }
        .file-upload { 
            border: 2px dashed #e1e5e9; border-radius: 8px;
            padding: 20px; text-align: center; cursor: pointer;
        }
        .file-upload:hover { border-color: #667eea; }
        .btn {
            width: 100%; padding: 15px; border: none; border-radius: 8px;
            font-size: 1.1rem; font-weight: 600; cursor: pointer;
            margin-top: 10px; transition: all 0.3s ease;
        }
        .btn-primary { background: #667eea; color: white; }
        .btn-success { background: #28a745; color: white; }
        .btn:hover { transform: translateY(-2px); }
        .btn:disabled { opacity: 0.6; cursor: not-allowed; transform: none !important; }
        .status { padding: 10px; border-radius: 5px; margin: 10px 0; text-align: center; }
        .status-success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status-error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .hidden { display: none; }
        .loading { display: none; text-align: center; color: #667eea; margin: 10px 0; }
    </style>
</head>
<body>
    <div class="container">
        <h1>Document Text Replacer</h1>
        
        <div class="form-group">
            <label for="old_text">Text to Find</label>
            <input type="text" id="old_text" placeholder="Enter text to replace..." required>
        </div>
        
        <div class="form-group">
            <label for="new_text">Replace With</label>
            <input type="text" id="new_text" placeholder="Enter replacement text...">
        </div>
        
        <div class="form-group">
            <label>Upload Files</label>
            <div class="file-upload" onclick="document.getElementById('files').click()">
                <p>Click to select files</p>
                <p style="font-size: 0.9em; color: #666;">PDF, CSV, XML, XPT, ZIP supported</p>
                <input type="file" id="files" multiple accept=".pdf,.csv,.xml,.xpt,.zip" style="display: none;">
            </div>
            <div id="file-info" style="margin-top: 10px; color: #667eea;"></div>
        </div>
        
        <button class="btn btn-primary" id="processBtn" disabled>Process Files</button>
        <div class="loading" id="loading">Processing...</div>
        <div id="status"></div>
        <button class="btn btn-success hidden" id="downloadBtn">Download Result</button>
    </div>

    <script>
        const fileInput = document.getElementById('files');
        const fileInfo = document.getElementById('file-info');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const loading = document.getElementById('loading');
        const status = document.getElementById('status');
        const oldText = document.getElementById('old_text');
        const newText = document.getElementById('new_text');
        
        let selectedFiles = [];
        
        // File selection
        fileInput.addEventListener('change', function(e) {
            selectedFiles = Array.from(e.target.files);
            if (selectedFiles.length > 0) {
                fileInfo.textContent = selectedFiles.length + ' file(s) selected: ' + 
                    selectedFiles.map(f => f.name).join(', ');
                checkForm();
            }
        });
        
        // Form validation
        function checkForm() {
            processBtn.disabled = !(selectedFiles.length > 0 && oldText.value.trim());
        }
        
        oldText.addEventListener('input', checkForm);
        newText.addEventListener('input', checkForm);
        
        // Process files
        processBtn.addEventListener('click', async function() {
            if (!selectedFiles.length || !oldText.value.trim()) return;
            
            const formData = new FormData();
            selectedFiles.forEach(file => formData.append('pdf_file', file));
            formData.append('old_text', oldText.value.trim());
            formData.append('new_text', newText.value.trim());
            
            processBtn.disabled = true;
            loading.style.display = 'block';
            status.innerHTML = '';
            downloadBtn.classList.add('hidden');
            
            try {
                console.log('Sending request to /upload');
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', response.status);
                console.log('Response headers:', response.headers);
                
                let result;
                const contentType = response.headers.get('content-type');
                
                if (contentType && contentType.includes('application/json')) {
                    result = await response.json();
                } else {
                    // If we get HTML instead of JSON, there's an error
                    const text = await response.text();
                    console.error('Expected JSON but got:', text.substring(0, 200));
                    throw new Error('Server returned HTML instead of JSON. Check server logs.');
                }
                
                if (result.success) {
                    status.innerHTML = '<div class="status status-success">' + result.message + '</div>';
                    downloadBtn.setAttribute('data-download-id', result.download_id);
                    downloadBtn.setAttribute('data-filename', result.filename);
                    downloadBtn.classList.remove('hidden');
                } else {
                    throw new Error(result.error || 'Processing failed');
                }
                
            } catch (error) {
                console.error('Error:', error);
                status.innerHTML = '<div class="status status-error">Error: ' + error.message + '</div>';
            } finally {
                processBtn.disabled = false;
                loading.style.display = 'none';
            }
        });
        
        // Download file
        downloadBtn.addEventListener('click', async function() {
            const downloadId = downloadBtn.getAttribute('data-download-id');
            const filename = downloadBtn.getAttribute('data-filename');
            
            try {
                const response = await fetch('/download/' + downloadId);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    a.remove();
                    URL.revokeObjectURL(url);
                    status.innerHTML = '<div class="status status-success">Download started!</div>';
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Download failed');
                }
            } catch (error) {
                status.innerHTML = '<div class="status status-error">Download error: ' + error.message + '</div>';
            }
        });
    </script>
</body>
</html>'''

# ---------------- File Processing Functions ----------------

def replace_text_in_pdf(input_pdf_path, old_text, new_text):
    """Replace text in PDF"""
    try:
        pdf_document = fitz.open(input_pdf_path)
        for page in pdf_document:
            text_instances = page.search_for(old_text)
            for rect in text_instances:
                page.add_redact_annot(rect)
            page.apply_redactions()
            for rect in text_instances:
                page.insert_text(fitz.Point(rect.x0, rect.y1 - 2), new_text, fontsize=12)
        
        output_path = input_pdf_path.replace('.pdf', '_modified.pdf')
        pdf_document.save(output_path)
        pdf_document.close()
        return output_path
    except Exception as e:
        print(f"PDF processing error: {e}")
        raise

def replace_text_in_csv(input_csv_path, old_text, new_text):
    """Replace text in CSV"""
    try:
        df = pd.read_csv(input_csv_path, dtype=str)
        df = df.applymap(lambda x: x.replace(old_text, new_text) if isinstance(x, str) else x)
        output_path = input_csv_path.replace('.csv', '_modified.csv')
        df.to_csv(output_path, index=False)
        return output_path
    except Exception as e:
        print(f"CSV processing error: {e}")
        raise

def replace_text_in_xml(input_xml_path, old_text, new_text):
    """Replace text in XML"""
    try:
        tree = ET.parse(input_xml_path)
        root = tree.getroot()
        
        def replace_in_element(elem):
            if elem.text and old_text in elem.text:
                elem.text = elem.text.replace(old_text, new_text)
            if elem.tail and old_text in elem.tail:
                elem.tail = elem.tail.replace(old_text, new_text)
            for k, v in elem.attrib.items():
                if old_text in v:
                    elem.attrib[k] = v.replace(old_text, new_text)
            for child in elem:
                replace_in_element(child)
        
        replace_in_element(root)
        output_path = input_xml_path.replace('.xml', '_modified.xml')
        tree.write(output_path, encoding="utf-8", xml_declaration=True)
        return output_path
    except Exception as e:
        print(f"XML processing error: {e}")
        raise

def replace_text_in_xpt(input_xpt_path, old_text, new_text):
    """Replace text in XPT"""
    try:
        df, meta = pyreadstat.read_xport(input_xpt_path)
        df = df.applymap(lambda x: x.replace(old_text, new_text) if isinstance(x, str) else x)
        output_path = input_xpt_path.replace('.xpt', '_modified.xpt')
        pyreadstat.write_xport(df, output_path, file_format_version=8, table_name=meta.table_name)
        return output_path
    except Exception as e:
        print(f"XPT processing error: {e}")
        raise

def process_single_file(file_path, old_text, new_text):
    """Process single file based on extension"""
    ext = os.path.splitext(file_path)[1].lower()
    if ext == '.pdf':
        return replace_text_in_pdf(file_path, old_text, new_text)
    elif ext == '.csv':
        return replace_text_in_csv(file_path, old_text, new_text)
    elif ext == '.xml':
        return replace_text_in_xml(file_path, old_text, new_text)
    elif ext == '.xpt':
        return replace_text_in_xpt(file_path, old_text, new_text)
    else:
        raise ValueError(f"Unsupported file type: {ext}")

# ---------------- Routes ----------------

@app.route('/')
def index():
    """Serve the HTML page"""
    return HTML_TEMPLATE

@app.route('/upload', methods=['POST'])
def upload_file():
    """Process uploaded files and return JSON response"""
    try:
        print("Upload endpoint hit")  # Debug log
        
        # Validate form data
        old_text = request.form.get('old_text', '').strip()
        new_text = request.form.get('new_text', '').strip()
        
        print(f"Old text: '{old_text}', New text: '{new_text}'")  # Debug log
        
        if not old_text:
            return jsonify({'success': False, 'error': 'Text to find is required'}), 400
        
        uploaded_files = request.files.getlist('pdf_file')
        print(f"Number of uploaded files: {len(uploaded_files)}")  # Debug log
        
        if not uploaded_files or all(file.filename == '' for file in uploaded_files):
            return jsonify({'success': False, 'error': 'No files selected'}), 400
        
        processed_files = []
        temp_files = []
        supported_extensions = ['.pdf', '.csv', '.xml', '.xpt', '.zip']
        
        # Process each file
        for file in uploaded_files:
            if file.filename == '':
                continue
                
            filename = secure_filename(file.filename)
            ext = os.path.splitext(filename)[1].lower()
            
            print(f"Processing file: {filename}, extension: {ext}")  # Debug log
            
            if ext not in supported_extensions:
                return jsonify({'success': False, 'error': f'Unsupported file type: {ext}'}), 400
            
            # Save file
            unique_filename = f"{uuid.uuid4()}_{filename}"
            file_path = os.path.join(UPLOAD_FOLDER, unique_filename)
            file.save(file_path)
            temp_files.append(file_path)
            
            # Process file
            if ext == '.zip':
                # For ZIP files, you'd implement ZIP processing here
                # For now, we'll skip ZIP processing to keep it simple
                return jsonify({'success': False, 'error': 'ZIP processing temporarily disabled'}), 400
            else:
                output_path = process_single_file(file_path, old_text, new_text)
                processed_files.append({
                    'path': output_path,
                    'name': f"modified_{filename}"
                })
        
        if not processed_files:
            return jsonify({'success': False, 'error': 'No files processed successfully'}), 400
        
        # Generate download ID
        download_id = str(uuid.uuid4())
        
        # Prepare final file
        if len(processed_files) == 1:
            final_file_path = processed_files[0]['path']
            final_filename = processed_files[0]['name']
        else:
            # Create ZIP for multiple files
            final_filename = f"modified_files.zip"
            final_file_path = os.path.join(UPLOAD_FOLDER, f"{download_id}_{final_filename}")
            with zipfile.ZipFile(final_file_path, 'w') as zip_ref:
                for processed_file in processed_files:
                    zip_ref.write(processed_file['path'], processed_file['name'])
        
        # Store for download
        processed_files_cache[download_id] = {
            'file_path': final_file_path,
            'filename': final_filename,
            'temp_files': temp_files + [pf['path'] for pf in processed_files]
        }
        
        # Schedule cleanup (5 minutes)
        def cleanup():
            try:
                if download_id in processed_files_cache:
                    file_info = processed_files_cache[download_id]
                    for temp_file in file_info['temp_files']:
                        if os.path.exists(temp_file):
                            os.remove(temp_file)
                    if os.path.exists(file_info['file_path']):
                        os.remove(file_info['file_path'])
                    del processed_files_cache[download_id]
            except Exception as e:
                print(f"Cleanup error: {e}")
        
        threading.Timer(300.0, cleanup).start()
        
        print("Processing successful, returning JSON")  # Debug log
        
        return jsonify({
            'success': True,
            'download_id': download_id,
            'filename': final_filename,
            'message': 'Files processed successfully!'
        })
    
    except Exception as e:
        print(f"Error in upload_file: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': str(e)}), 500

@app.route('/download/<download_id>')
def download_file(download_id):
    """Download processed file"""
    try:
        if download_id not in processed_files_cache:
            return jsonify({'error': 'File not found or expired'}), 404
        
        file_info = processed_files_cache[download_id]
        
        if not os.path.exists(file_info['file_path']):
            return jsonify({'error': 'File no longer available'}), 404
        
        return send_file(
            file_info['file_path'],
            as_attachment=True,
            download_name=file_info['filename'],
            mimetype='application/octet-stream'
        )
    
    except Exception as e:
        print(f"Error in download_file: {str(e)}")
        return jsonify({'error': str(e)}), 500

# Error handlers
@app.errorhandler(404)
def not_found_error(error):
    return jsonify({'success': False, 'error': 'Endpoint not found'}), 404

@app.errorhandler(413)
def too_large(e):
    return jsonify({'success': False, 'error': 'File too large. Maximum size is 50MB'}), 413

@app.errorhandler(500)
def internal_error(error):
    return jsonify({'success': False, 'error': 'Internal server error'}), 500

if __name__ == "__main__":
    print("Starting Flask app...")
    print(f"Upload folder: {UPLOAD_FOLDER}")
    app.run(host="0.0.0.0", port=5000, debug=True)
