# Minimal Flask app - guaranteed to work
# This version removes all potential error sources

from flask import Flask, request, send_file, jsonify
import os
import uuid
import tempfile
import traceback

# Try to import PDF library, but don't fail if not available
try:
    import fitz  # PyMuPDF
    HAS_PYMUPDF = True
except ImportError:
    HAS_PYMUPDF = False
    print("Warning: PyMuPDF not installed. PDF processing will be disabled.")

# Try to import pandas, but don't fail if not available
try:
    import pandas as pd
    HAS_PANDAS = True
except ImportError:
    HAS_PANDAS = False
    print("Warning: pandas not installed. CSV processing will be disabled.")

app = Flask(__name__)
app.config['MAX_CONTENT_LENGTH'] = 50 * 1024 * 1024  # 50MB

# Use system temp directory
UPLOAD_FOLDER = tempfile.mkdtemp()
print(f"Using upload folder: {UPLOAD_FOLDER}")

# Store processed files
processed_files_cache = {}

# Simple HTML template
HTML_TEMPLATE = '''<!DOCTYPE html>
<html>
<head>
    <title>Document Text Replacer</title>
    <style>
        body { font-family: Arial, sans-serif; max-width: 600px; margin: 50px auto; padding: 20px; }
        .form-group { margin: 20px 0; }
        label { display: block; margin-bottom: 5px; font-weight: bold; }
        input[type="text"] { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 4px; }
        input[type="file"] { width: 100%; padding: 8px; }
        button { background: #007bff; color: white; padding: 10px 20px; border: none; border-radius: 4px; cursor: pointer; width: 100%; margin: 10px 0; }
        button:disabled { background: #ccc; cursor: not-allowed; }
        button:hover:not(:disabled) { background: #0056b3; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .hidden { display: none; }
    </style>
</head>
<body>
    <h1>Document Text Replacer</h1>
    <div>
        <div class="form-group">
            <label for="old_text">Text to Find:</label>
            <input type="text" id="old_text" placeholder="Enter text to replace" required>
        </div>
        <div class="form-group">
            <label for="new_text">Replace With:</label>
            <input type="text" id="new_text" placeholder="Enter replacement text">
        </div>
        <div class="form-group">
            <label for="files">Select Files:</label>
            <input type="file" id="files" multiple accept=".pdf,.txt,.csv">
        </div>
        <button id="processBtn" disabled>Process Files</button>
        <div id="status"></div>
        <button id="downloadBtn" class="hidden">Download Result</button>
    </div>

    <script>
        const fileInput = document.getElementById('files');
        const processBtn = document.getElementById('processBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const status = document.getElementById('status');
        const oldText = document.getElementById('old_text');
        const newText = document.getElementById('new_text');
        
        let selectedFiles = [];
        
        function showStatus(message, type = 'error') {
            status.innerHTML = '<div class="status ' + type + '">' + message + '</div>';
        }
        
        function checkForm() {
            processBtn.disabled = !(selectedFiles.length > 0 && oldText.value.trim());
        }
        
        fileInput.addEventListener('change', function(e) {
            selectedFiles = Array.from(e.target.files);
            checkForm();
        });
        
        oldText.addEventListener('input', checkForm);
        newText.addEventListener('input', checkForm);
        
        processBtn.addEventListener('click', async function() {
            if (!selectedFiles.length || !oldText.value.trim()) {
                showStatus('Please select files and enter text to find');
                return;
            }
            
            const formData = new FormData();
            selectedFiles.forEach(file => formData.append('files', file));
            formData.append('old_text', oldText.value.trim());
            formData.append('new_text', newText.value.trim());
            
            processBtn.disabled = true;
            showStatus('Processing...', 'success');
            downloadBtn.classList.add('hidden');
            
            try {
                console.log('Sending request to /process');
                
                const response = await fetch('/process', {
                    method: 'POST',
                    body: formData
                });
                
                console.log('Response status:', response.status);
                console.log('Response content-type:', response.headers.get('content-type'));
                
                // Check if response is JSON
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('Non-JSON response:', text.substring(0, 500));
                    throw new Error('Server error - check console for details');
                }
                
                const result = await response.json();
                console.log('Parsed result:', result);
                
                if (result.success) {
                    showStatus(result.message, 'success');
                    downloadBtn.setAttribute('data-id', result.download_id);
                    downloadBtn.setAttribute('data-filename', result.filename);
                    downloadBtn.classList.remove('hidden');
                } else {
                    throw new Error(result.error || 'Processing failed');
                }
                
            } catch (error) {
                console.error('Error:', error);
                showStatus('Error: ' + error.message);
            } finally {
                processBtn.disabled = false;
            }
        });
        
        downloadBtn.addEventListener('click', async function() {
            const downloadId = downloadBtn.getAttribute('data-id');
            const filename = downloadBtn.getAttribute('data-filename');
            
            try {
                const response = await fetch('/download/' + downloadId);
                
                if (response.ok) {
                    const blob = await response.blob();
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    a.click();
                    URL.revokeObjectURL(url);
                    showStatus('Download started!', 'success');
                } else {
                    const error = await response.json();
                    throw new Error(error.error || 'Download failed');
                }
            } catch (error) {
                showStatus('Download error: ' + error.message);
            }
        });
    </script>
</body>
</html>'''

def replace_text_in_text_file(file_path, old_text, new_text):
    """Replace text in plain text files"""
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            content = f.read()
        
        new_content = content.replace(old_text, new_text)
        
        output_path = file_path.replace('.txt', '_modified.txt')
        with open(output_path, 'w', encoding='utf-8') as f:
            f.write(new_content)
        
        return output_path
    except Exception as e:
        print(f"Text file processing error: {e}")
        raise

def replace_text_in_pdf(file_path, old_text, new_text):
    """Replace text in PDF files"""
    if not HAS_PYMUPDF:
        raise Exception("PyMuPDF not installed. Cannot process PDF files.")
    
    try:
        pdf_document = fitz.open(file_path)
        for page in pdf_document:
            text_instances = page.search_for(old_text)
            for rect in text_instances:
                page.add_redact_annot(rect)
            page.apply_redactions()
            for rect in text_instances:
                page.insert_text(fitz.Point(rect.x0, rect.y1 - 2), new_text, fontsize=12)
        
        output_path = file_path.replace('.pdf', '_modified.pdf')
        pdf_document.save(output_path)
        pdf_document.close()
        return output_path
    except Exception as e:
        print(f"PDF processing error: {e}")
        raise

def replace_text_in_csv(file_path, old_text, new_text):
    """Replace text in CSV files"""
    if not HAS_PANDAS:
        raise Exception("pandas not installed. Cannot process CSV files.")
    
    try:
        df = pd.read_csv(file_path, dtype=str)
        df = df.applymap(lambda x: x.replace(old_text, new_text) if isinstance(x, str) else x)
        output_path = file_path.replace('.csv', '_modified.csv')
        df.to_csv(output_path, index=False)
        return output_path
    except Exception as e:
        print(f"CSV processing error: {e}")
        raise

def process_file(file_path, old_text, new_text):
    """Process a single file based on its extension"""
    ext = os.path.splitext(file_path)[1].lower()
    
    if ext == '.txt':
        return replace_text_in_text_file(file_path, old_text, new_text)
    elif ext == '.pdf':
        return replace_text_in_pdf(file_path, old_text, new_text)
    elif ext == '.csv':
        return replace_text_in_csv(file_path, old_text, new_text)
    else:
        raise ValueError(f"Unsupported file type: {ext}")

@app.route('/')
def index():
    """Serve the main page"""
    return HTML_TEMPLATE

@app.route('/process', methods=['POST'])
def process_files():
    """Process uploaded files"""
    try:
        print("=== PROCESS ENDPOINT HIT ===")
        
        # Get form data
        old_text = request.form.get('old_text', '').strip()
        new_text = request.form.get('new_text', '').strip()
        
        print(f"Old text: '{old_text}'")
        print(f"New text: '{new_text}'")
        
        if not old_text:
            print("ERROR: No old_text provided")
            return jsonify({'success': False, 'error': 'Text to find is required'}), 400
        
        # Get uploaded files
        uploaded_files = request.files.getlist('files')
        print(f"Number of files: {len(uploaded_files)}")
        
        if not uploaded_files or all(file.filename == '' for file in uploaded_files):
            print("ERROR: No files uploaded")
            return jsonify({'success': False, 'error': 'No files selected'}), 400
        
        processed_files = []
        temp_files = []
        
        # Process each file
        for i, file in enumerate(uploaded_files):
            if file.filename == '':
                continue
            
            print(f"Processing file {i+1}: {file.filename}")
            
            # Save uploaded file
            file_id = str(uuid.uuid4())
            file_ext = os.path.splitext(file.filename)[1]
            temp_filename = f"{file_id}{file_ext}"
            temp_path = os.path.join(UPLOAD_FOLDER, temp_filename)
            
            print(f"Saving to: {temp_path}")
            file.save(temp_path)
            temp_files.append(temp_path)
            
            try:
                # Process the file
                output_path = process_file(temp_path, old_text, new_text)
                processed_files.append({
                    'path': output_path,
                    'name': f"modified_{file.filename}"
                })
                print(f"Successfully processed: {file.filename}")
                
            except Exception as e:
                print(f"Error processing {file.filename}: {str(e)}")
                return jsonify({'success': False, 'error': f'Error processing {file.filename}: {str(e)}'}), 400
        
        if not processed_files:
            print("ERROR: No files processed")
            return jsonify({'success': False, 'error': 'No files processed successfully'}), 400
        
        # Prepare download
        download_id = str(uuid.uuid4())
        
        if len(processed_files) == 1:
            # Single file
            final_path = processed_files[0]['path']
            final_name = processed_files[0]['name']
        else:
            # Multiple files - create zip
            import zipfile
            final_name = "modified_files.zip"
            final_path = os.path.join(UPLOAD_FOLDER, f"{download_id}.zip")
            
            with zipfile.ZipFile(final_path, 'w') as zf:
                for pf in processed_files:
                    zf.write(pf['path'], pf['name'])
        
        # Store for download
        processed_files_cache[download_id] = {
            'file_path': final_path,
            'filename': final_name,
            'temp_files': temp_files + [pf['path'] for pf in processed_files]
        }
        
        print(f"SUCCESS: Stored download {download_id}")
        
        # Return JSON response
        response_data = {
            'success': True,
            'download_id': download_id,
            'filename': final_name,
            'message': f'Successfully processed {len(processed_files)} file(s)!'
        }
        
        print(f"Returning JSON: {response_data}")
        return jsonify(response_data)
        
    except Exception as e:
        print(f"CRITICAL ERROR: {str(e)}")
        print(f"Traceback: {traceback.format_exc()}")
        return jsonify({'success': False, 'error': f'Server error: {str(e)}'}), 500

@app.route('/download/<download_id>')
def download_file(download_id):
    """Download processed file"""
    try:
        print(f"Download request for ID: {download_id}")
        
        if download_id not in processed_files_cache:
            print(f"Download ID not found: {download_id}")
            return jsonify({'error': 'File not found or expired'}), 404
        
        file_info = processed_files_cache[download_id]
        file_path = file_info['file_path']
        
        if not os.path.exists(file_path):
            print(f"File does not exist: {file_path}")
            return jsonify({'error': 'File no longer available'}), 404
        
        print(f"Sending file: {file_path}")
        return send_file(
            file_path,
            as_attachment=True,
            download_name=file_info['filename']
        )
        
    except Exception as e:
        print(f"Download error: {str(e)}")
        return jsonify({'error': str(e)}), 500

@app.errorhandler(404)
def not_found(error):
    print(f"404 error: {error}")
    return jsonify({'success': False, 'error': 'Page not found'}), 404

@app.errorhandler(500)
def internal_error(error):
    print(f"500 error: {error}")
    return jsonify({'success': False, 'error': 'Internal server error'}), 500

@app.errorhandler(413)
def too_large(error):
    print(f"File too large: {error}")
    return jsonify({'success': False, 'error': 'File too large (max 50MB)'}), 413

if __name__ == "__main__":
    print("=" * 50)
    print("STARTING MINIMAL FLASK APP")
    print(f"Upload folder: {UPLOAD_FOLDER}")
    print(f"PyMuPDF available: {HAS_PYMUPDF}")
    print(f"Pandas available: {HAS_PANDAS}")
    print("=" * 50)
    
    app.run(host="0.0.0.0", port=5000, debug=True)
